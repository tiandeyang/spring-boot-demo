把不变的抽离出去 做成独立的服务  消息推送 微信支付 地址相关


长轮训机制 hold请求 不返回 直到有需要的消息再返回


预见异常 捕获异常 包装异常 抛出异常 回滚
还有一种异常处理方式  比如在 定时任务里面循环调用 微信订单支付状态查询接口  如果抛出异常 则需要捕获  定时任务不能被中断
此时 可以额外记录下 以备补偿处理

# 数据库设计
诸如 年龄、钱包余额、销量字段 有必要设置默认值为数字类型  不要再默认为NULL了 unfriendly
用户提现开关 放在账户表更为合适 不应该放在用户表

# 接口设计
基本上一个页面封装成一个接口 页面内的操作按钮对应一个接口  但有时候  页面的按钮显示与否 是根据状态来的  也就是说 页面对应的接口不止数据 还包含按钮的状态
保持接口幂等性原则之一  状态的更改 一定要把前置状态作为条件
接口也要遵循模块化思想


#不可用状态(异常状态)

订单支付成功了 订单所附加的积分 机会次数 会生效
但是 用户一旦申请了 退款  积分 及 次数 就会进入 不可用状态（异常状态）
当 处理中时 保持不可用状态；当 进入最终状态时 平台予以退款了或平台驳回了 则次数会失效 机会失效 或 不可用状态改为 可用状态

# 安全
CSRF 跨站伪造请求  解决方案  anti TOKEN

# 产品
不能让用户流畅的用户体验戛然而止 不要让用户返回 就一直点下去 购物车为空，则有相应的产品推荐 ；订单为空 则有热门商品顶上；点进去一个活动分享；
体现在产品的设计上 就是不要有白屏也买呢

# 页面上的点击按钮 事件的触发器 ；定时任务 也是事件的触发器；
# 防重复提交 首推方案 基于缓存的计数器方案 可以提高系统的qps的峰值  以退款为例子：
每次request进来则新建一个以orderId为key的计数器，然后＋1。

如果>1（不能获得锁）: 说明有操作在进行，删除。

如果=1（获得锁）: 可以操作。
操作结束（删除锁）：删除这个计数器

#springcloud 常见问题

# 微信 accessToken 全局化服务化 否则 服务1 更改了Token 会影响到服务2的 接口调用 ;最好是  生产、测试 两套公众号 相互隔离
# redis
 今天有个业务场景用到了 redis的队列；前端通过用户的点击 获取 formid 资源，调用接口传至后端，后端取到值  放入 一个以当前 用户表示为 KEY 的 队列中 ；因为formid 存在有效期限制  需要 将其包装一下 再存入队列 ；取出的时候  判断下 过期时间即可。

# 日志
入参打日志  出参打日志   分支打日志
debug 尽量在本地
生产环境看日志 太麻烦啊


#咋咋回事
通用语言很关键 一致定义  团长 跟 上级 可不是同一个意思



